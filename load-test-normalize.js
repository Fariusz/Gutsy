#!/usr/bin/env node

/**
 * Load testing script for the ingredient normalization endpoint
 * Tests performance under concurrent load and validates rate limiting
 */

const ENDPOINT_URL = 'http://localhost:3000/api/ingredients/normalize';

// Test datasets with various complexity levels
const testInputs = [
  'tomatoes',
  'spicy tomato sauce',
  'organic free-range chicken breast',
  'fresh basil and oregano leaves',
  '2 cups of diced onions with garlic',
  'extra virgin olive oil, sea salt, and black pepper',
  'gluten-free whole wheat pasta with marinara sauce',
  'thick-cut bacon, eggs, and sharp cheddar cheese',
  'strawberries, blueberries, and vanilla greek yogurt',
  'grilled salmon with lemon herb butter and asparagus'
];\

/**
 * Simulates a user session with multiple normalization requests
 */
async function simulateUserSession(sessionId, requestCount = 5) {
  console.log(`üîÑ Session ${sessionId}: Starting ${requestCount} requests`);\n  const results = [];\n  \n  for (let i = 0; i < requestCount; i++) {\n    const testInput = testInputs[Math.floor(Math.random() * testInputs.length)];\n    const startTime = Date.now();\n    \n    try {\n      const response = await fetch(ENDPOINT_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer test-session-${sessionId}`\n        },\n        body: JSON.stringify({ raw_text: testInput })\n      });\n\n      const endTime = Date.now();\n      const data = await response.json();\n      \n      results.push({\n        sessionId,\n        requestIndex: i,\n        input: testInput,\n        status: response.status,\n        responseTime: endTime - startTime,\n        matchCount: response.status === 200 ? data.data?.length || 0 : 0,\n        success: response.status === 200\n      });\n      \n      // Small delay between requests to be realistic\n      await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 400));\n    } catch (error) {\n      results.push({\n        sessionId,\n        requestIndex: i,\n        input: testInput,\n        status: 0,\n        responseTime: Date.now() - startTime,\n        matchCount: 0,\n        success: false,\n        error: error.message\n      });\n    }\n  }\n  \n  console.log(`‚úÖ Session ${sessionId}: Completed ${results.filter(r => r.success).length}/${requestCount} requests`);\n  return results;\n}\n\n/**\n * Runs concurrent load test with specified parameters\n */\nasync function runLoadTest(concurrentSessions = 5, requestsPerSession = 3) {\n  console.log('üöÄ Starting Ingredient Normalization Load Test');\n  console.log(`üìä Config: ${concurrentSessions} sessions √ó ${requestsPerSession} requests = ${concurrentSessions * requestsPerSession} total requests`);\n  console.log('=' .repeat(60));\n  \n  const startTime = Date.now();\n  \n  // Launch concurrent user sessions\n  const sessionPromises = Array.from({ length: concurrentSessions }, (_, i) => \n    simulateUserSession(i + 1, requestsPerSession)\n  );\n  \n  const allResults = await Promise.all(sessionPromises);\n  const flatResults = allResults.flat();\n  \n  const endTime = Date.now();\n  const totalTime = endTime - startTime;\n  \n  // Analyze results\n  const totalRequests = flatResults.length;\n  const successfulRequests = flatResults.filter(r => r.success).length;\n  const failedRequests = totalRequests - successfulRequests;\n  const avgResponseTime = flatResults.reduce((sum, r) => sum + r.responseTime, 0) / totalRequests;\n  const p95ResponseTime = flatResults\n    .map(r => r.responseTime)\n    .sort((a, b) => a - b)[Math.floor(totalRequests * 0.95)];\n  \n  const statusCounts = flatResults.reduce((acc, r) => {\n    acc[r.status] = (acc[r.status] || 0) + 1;\n    return acc;\n  }, {});\n  \n  // Print results\n  console.log('\\n' + '='.repeat(60));\n  console.log('üìà LOAD TEST RESULTS');\n  console.log('=' .repeat(60));\n  console.log(`‚è±Ô∏è  Total Test Time: ${totalTime}ms (${(totalTime / 1000).toFixed(2)}s)`);\n  console.log(`üì® Total Requests: ${totalRequests}`);\n  console.log(`‚úÖ Successful: ${successfulRequests} (${((successfulRequests / totalRequests) * 100).toFixed(1)}%)`);\n  console.log(`‚ùå Failed: ${failedRequests} (${((failedRequests / totalRequests) * 100).toFixed(1)}%)`);\n  console.log(`‚ö° Avg Response Time: ${avgResponseTime.toFixed(0)}ms`);\n  console.log(`üìä P95 Response Time: ${p95ResponseTime}ms`);\n  console.log(`üî¢ Requests/Second: ${(totalRequests / (totalTime / 1000)).toFixed(2)}`);\n  \n  console.log('\\nüìã Status Code Distribution:');\n  Object.entries(statusCounts)\n    .sort(([a], [b]) => Number(a) - Number(b))\n    .forEach(([status, count]) => {\n      console.log(`  ${status}: ${count} requests`);\n    });\n  \n  // Performance warnings\n  if (avgResponseTime > 2000) {\n    console.log('\\n‚ö†Ô∏è  WARNING: Average response time > 2s - consider optimization');\n  }\n  if (failedRequests > totalRequests * 0.01) {\n    console.log('\\n‚ö†Ô∏è  WARNING: Error rate > 1% - investigate failures');\n  }\n  \n  // Rate limiting analysis\n  const rateLimitedRequests = flatResults.filter(r => r.status === 429).length;\n  if (rateLimitedRequests > 0) {\n    console.log(`\\nüõ°Ô∏è  Rate Limiting: ${rateLimitedRequests} requests rate limited (working as intended)`);\n  }\n  \n  console.log('\\nüèÅ Load test completed successfully!');\n}\n\n/**\n * Performance benchmarking for different input types\n */\nasync function runPerformanceBenchmark() {\n  console.log('üéØ Running Performance Benchmark');\n  console.log('=' .repeat(40));\n  \n  const benchmarkInputs = [\n    { name: 'Simple', text: 'tomatoes' },\n    { name: 'Medium', text: 'spicy tomato sauce with basil' },\n    { name: 'Complex', text: 'organic free-range chicken breast with herbs and spices' },\n    { name: 'Very Complex', text: '2 cups organic diced tomatoes, 1 tbsp extra virgin olive oil, fresh basil leaves, garlic, and sea salt' }\n  ];\n  \n  for (const input of benchmarkInputs) {\n    const times = [];\n    const testRuns = 10;\n    \n    console.log(`\\nüß™ Testing \"${input.name}\" complexity (${testRuns} runs)`);\n    console.log(`   Input: \"${input.text}\"`);\n    \n    for (let i = 0; i < testRuns; i++) {\n      const startTime = Date.now();\n      \n      try {\n        const response = await fetch(ENDPOINT_URL, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer benchmark-test`\n          },\n          body: JSON.stringify({ raw_text: input.text })\n        });\n        \n        const endTime = Date.now();\n        const responseTime = endTime - startTime;\n        times.push(responseTime);\n        \n        if (i === 0) {\n          // Log first response for validation\n          const data = await response.json();\n          console.log(`   Status: ${response.status}, Matches: ${data.data?.length || 0}`);\n        }\n      } catch (error) {\n        console.log(`   ‚ùå Request ${i + 1} failed: ${error.message}`);\n      }\n      \n      // Small delay between benchmark runs\n      await new Promise(resolve => setTimeout(resolve, 50));\n    }\n    \n    // Calculate statistics\n    times.sort((a, b) => a - b);\n    const avg = times.reduce((sum, t) => sum + t, 0) / times.length;\n    const min = times[0];\n    const max = times[times.length - 1];\n    const median = times[Math.floor(times.length / 2)];\n    \n    console.log(`   üìä Min: ${min}ms, Avg: ${avg.toFixed(1)}ms, Median: ${median}ms, Max: ${max}ms`);\n  }\n}\n\n// Main execution\nasync function main() {\n  try {\n    console.log('‚ö†Ô∏è  Make sure the development server is running on localhost:3000');\n    console.log('‚ö†Ô∏è  These tests use mock authentication - update for real testing\\n');\n    \n    // Run performance benchmark first\n    await runPerformanceBenchmark();\n    \n    console.log('\\n' + '='.repeat(60));\n    \n    // Then run load test\n    await runLoadTest(3, 4); // 3 sessions √ó 4 requests = 12 total requests\n    \n  } catch (error) {\n    console.error('‚ùå Test execution failed:', error);\n    process.exit(1);\n  }\n}\n\n// Uncomment to run load tests (ensure server is running)\n// main().catch(console.error);\n\nconsole.log('Load test script ready. Uncomment main() and ensure server is running to execute tests.');